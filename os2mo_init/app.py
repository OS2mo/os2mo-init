# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0

import structlog
from authlib.integrations.httpx_client import AsyncOAuth2Client
from fastramqpi.app import configure_logging

from os2mo_init.autogenerated_graphql_client import GraphQLClient
from os2mo_init.classes import ensure_classes
from os2mo_init.config import ConfigFile
from os2mo_init.config import Settings
from os2mo_init.config import get_config_file
from os2mo_init.facets import ensure_facets
from os2mo_init.it_systems import ensure_it_systems
from os2mo_init.root_org import ensure_root_organisation

logger = structlog.stdlib.get_logger()

# Heavily inspired by
# https://git.magenta.dk/rammearkitektur/FastRAMQPI/-/blob/77411a70890f49e91444d14d886f263e379c8827/fastramqpi/main.py


def create_clients(settings: Settings) -> tuple[AsyncOAuth2Client, GraphQLClient]:
    # Authenticated HTTPX Client
    mo_client = AsyncOAuth2Client(
        base_url=settings.mo_url,
        client_id=settings.client_id,
        client_secret=settings.client_secret.get_secret_value(),
        grant_type="client_credentials",
        # TODO: We should take a full token URL instead of hard-coding Keycloak's
        # URL scheme. Let's wait until the legacy clients are removed.
        token_endpoint=f"{settings.auth_server}/realms/{settings.auth_realm}/protocol/openid-connect/token",
        # TODO (https://github.com/lepture/authlib/issues/531): Hack to enable
        # automatic fetching of token on first call, instead of only refreshing.
        token={"expires_at": -1, "access_token": ""},
        timeout=settings.graphql_timeout,
    )
    # GraphQL Client
    graphql_version = 20  # grep-compatibility with our other integrations
    graphql_client = GraphQLClient(
        url=f"{settings.mo_url}/graphql/v{graphql_version}",
        http_client=mo_client,
    )
    return mo_client, graphql_client


async def init(config: ConfigFile, graphql_client: GraphQLClient) -> None:
    # Root Organisation
    if config.root_organisation is not None:
        logger.info("Handling root organisation")
        await ensure_root_organisation(graphql_client, config.root_organisation)

    # IT Systems
    # NOTE: This MUST come before classes, since they can reference IT-systems
    if config.it_systems is not None:
        await ensure_it_systems(graphql_client, config.it_systems)

    # Facets
    # Even though facets are objects in the database equal to classes, they are
    # hard-coded everywhere. For this reason, OS2mo-init will *always* create this
    # expected set of facets.
    facets = {
        "address_property",
        "association_type",
        "employee_address_type",
        "engagement_job_function",
        "engagement_type",
        "kle_aspect",
        "kle_number",
        "leave_type",
        "manager_address_type",
        "manager_level",
        "manager_type",
        "org_unit_address_type",
        "org_unit_hierarchy",
        "org_unit_level",
        "org_unit_type",
        "primary_type",
        "responsibility",
        "role",
        "time_planning",
        "visibility",
    }
    await ensure_facets(graphql_client, facets)

    # Classes
    if config.facets is not None:
        await ensure_classes(graphql_client, config.facets)


async def main() -> None:
    settings = Settings()
    configure_logging(settings.log_level)
    mo_client, graphql_client = create_clients(settings)
    config = get_config_file(settings.config_file)
    async with mo_client, graphql_client:
        await init(config, graphql_client)
